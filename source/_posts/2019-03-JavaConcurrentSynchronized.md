---
title: 理解synchronized的实现原理
date: 2019-01-26 15:14:46
categories: 
- JVM并发
tags:
- JVM并发
- synchronized
---



# 1 实现原理

> `synchronized`可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量内存可见性。



Java 中每一个对象都可以作为锁，这是 `synchronized` 实现同步的基础：

1. 普通同步方法，锁是当前实例对象
2. 静态同步方法，锁是当前类的 class 对象
3. 同步方法块，锁是括号里面的对象

PS:1）同步代码块是使用`monitorenter`和`monitorexit`指令来实现的。2）同步方法依靠的是方法修饰符上的`ACC_SYNCHRONIZED`实现。



任何对象都可以成为锁，那么锁的信息又存在在内存的什么地方呢？Java对象头。



# 2 Java对象头

Java对象头中的信息：

1. Mark Word。存储对象的hashcode、分代年龄、锁类型和锁标记位。
2. Class Metadata Address。存储到对象类型数据的指针。
3. Array Length。数组的长度（如果当前对象是数组）



Java 对象头一般占有两个机器码（在 32 位虚拟机中，1 个机器码等于 4 字节，也就是 32 bits）。但是如果对象是数组类型，则需要三个机器码，因为 JVM 虚拟机可以通过 Java 对象的元数据信息确定 Java 对象的大小，无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。

下图是Java对象头的存储结构（32位虚拟机）:

![Imgur](https://i.imgur.com/eDesOCQ.png)



在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为以下四种数据：

![Imgur](https://i.imgur.com/9O87S1I.png)



在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下表：

![Imgur](https://i.imgur.com/efQh3xN.png)



# 3 Monitor

每个Java对象天生自带一把看不见的锁。



# 3 锁的升级

简单来说，在 JVM 中 `monitorenter` 和 `monitorexit` 字节码依赖于底层的操作系统的Mutex Lock 来实现的，但是由于使用 Mutex Lock 需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。然而，在现实中的大部分情况下，同步方法是运行在单线程环境（**无锁竞争环境**），如果每次都调用 Mutex Lock 那么将严重的影响程序的性能。



因此，JDK 1.6 为了减少获得锁和释放锁带来的性能问题，引入了“偏向锁”和“轻量级锁”。在Java SE1.6中，锁一共有四种状态，从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争逐渐升级。值得注意的是，**锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率**。



下面依次介绍下各类锁：



## 3.1 偏向锁

引入偏向锁主要**目的**是：在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得，为了让线程获取锁的代价更低引入偏向锁。



### 获取偏向锁

1. 检测 Mark Word是 否为可偏向状态，即是否为偏向锁的标识位为 `1` ，锁标识位为 `01` 。
2. 若为可偏向状态，则测试线程 ID 是否为当前线程 ID ？如果**是**，则执行步骤（5）；**否则**，执行步骤（3）。
3. 如果线程 ID 不为当前线程 ID ，则通过 CAS 操作竞争锁。竞争**成功**，则将 Mark Word 的线程 ID 替换为**当前**线程 ID ，则执行步骤（5）；**否则**，执行线程（4）。
4. 通过 CAS 竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，**偏向锁升级为轻量级锁**，然后被阻塞在安全点的线程继续往下执行同步代码块。
5. 执行同步代码块



### 撤销偏向锁

**偏向锁的释放采用了一种只有竞争才会释放锁的机制**，线程是**不会主动**去释放偏向锁，需要等待其他线程来竞争。

偏向锁的撤销需要等待**全局安全点**（这个时间点是上没有正在执行的代码）。其步骤如下：

1. 暂停拥有偏向锁的线程，判断锁对象是否还处于被锁定状态。
2. 撤销偏向锁，恢复到无锁状态（ `01` ）或者轻量级锁的状态。



下图是偏向锁的获取和释放流程：

![Imgur](https://i.imgur.com/kP95fre.png)



### 关闭偏向锁

偏向锁在 JDK 1.6 以上，默认开启。开启后程序启动几秒后才会被激活，可使用 JVM 参数 `-XX：BiasedLockingStartupDelay = 0` 来关闭延迟。

如果确定锁**通常处于竞争状态**，则可通过JVM参数 `-XX:-UseBiasedLocking=false` 关闭偏向锁，那么默认会进入轻量级锁。



## 3.2 轻量级锁

引入轻量级锁的主要目的，是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

当关闭偏向锁功能或者多个线程竞争偏向锁，导致**偏向锁升级为轻量级锁**，则会尝试获取轻量级锁，其步骤如下：

### 获取锁

1. 判断当前对象是否处于无锁状态？**若是**，则 JVM 首先将在当前线程的栈帧中，建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word的 拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word）；**否则**，执行步骤（3）；
2. JVM 利用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指正。如果**成功**，表示竞争到锁，则将锁标志位变成 `00`（表示此对象处于轻量级锁状态），执行同步操作；如果**失败**，则执行步骤（3）；
3. 判断当前对象的 Mark Word 是否指向当前线程的栈帧？如果**是**，则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；**否则**，只能说明该锁对象已经被其他线程抢占了，当前线程便尝试使用**自旋**来获取锁。若自旋后没有获得锁，此时轻量级锁会升级为重量级锁，锁标志位变成 `10`，当前线程会被阻塞。

### 释放锁

轻量级锁的释放也是通过 CAS 操作来进行的，主要步骤如下：

1. 取出在获取轻量级锁保存在 Displaced Mark Word 中 数据。
2. 使用 CAS 操作将取出的数据替换当前对象的 Mark Word 中。如果**成功**，则说明释放锁成功；**否则**，执行（3）。



下图是争夺锁导致的**锁膨胀**的流程图：

![Imgur](https://i.imgur.com/CD3kdx7.png)



## 3.3 重量级锁

重量级锁通过对象内部的监视器（Monitor）实现。

其中，Monitor 的**本质**是，依赖于底层操作系统的Mutex Lock实现。操作系统实现线程之间的切换，需要从用户态到内核态的切换，切换成本非常高。



## 对比和总结

![Imgur](https://i.imgur.com/BB4ktPh.png)



> 参考：《Java并发编程的艺术》

